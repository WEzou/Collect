/*:
 # Object基础
 
 * 分类
 * 关联对象
 * 扩展
 * 代理
 * 通知
 * KVO
 * KVC
 * 属性关键字
 
 ----------
 
 #### 1、分类
 
  **分类的作用**
 
 * 1、声明私有方法
 * 2、分解体积庞大的类文件
 * 3、把Framework的私有方法公开（系统的私有方法）

  **分类的特点**
 * 1、运行时决议（编写分类文件后，并没有在编译的时候把分类中添加的内容附加到相应的宿主类中，而是在运行时，通过Runtime将内容的真实的添加到 宿主类中）-> 与扩展最大的区别
 
 * 2、可以为系统类添加分类  -> 不能给系统类添加扩展
 
  **分类添加的内容**
 
 * 1、实例方法
 * 2、类方法
 * 3、协议
 * 4、属性（定义属性，实际只声明 set、get方法，没有添加实例变量， 但可以通过关联对象，添加实例变量）
 
  **分类结构**
 
 ![IMG_3899](IMG_3899.PNG)
 
  **分类加载调用栈**
 
 * 最后编译的分类的同名方法才会最终生效，前面编译的同名方法会被覆盖（倒序插入编译的分类）
 * 分类的内容会插入到宿主类的前面，所以分类方法会覆盖宿主类的方法
 * 名字相同的分类回引起编译报错
 
  分类插入的大致流程：
 * 1、根据分类+宿主类的总大小，重新分配内存。   ——>   eg: size = 3  [ [ 宿主类],[], [] ]
 * 2、将原宿主类的内存后移。    ——> [ [ ],[], [宿主类] ]
 * 3、内存拷贝，将分类的内容插入到原宿主类的前面。     ——> [ [ 分类1],[分类2], [宿主类] ]
 
 
 #### 2、关联对象
 
  **关联对象的使用**
 
 // object：类    policy：策略
 * objc_getAssociatedObject(object: Any, key: UnsafeRawPointer)
 * objc_setAssociatedObject(object: Any, key: UnsafeRawPointer, value: Any, policy: objc_AssociationPolicy)
 * objc_removeAssociatedObjects(object: Any)

  **关联对象的本质**
 
 * 关联对象由**AssociationsManager**管理在**AssociationHashMap**存储
 * 所有对象的关联内容都在同一个全局容器中
  
 ![IMG_3902](IMG_3902.PNG)
 
 * **value** 和 **policy** 封装成 **ObjcAssociation**结构
 * 通过 **[key: ObjcAssociation]** 形式存储到 **ObjcAssociationMap** 结构中
 * 被关联对象的指针值 **DISGUISE(objc)** 与 **ObjcAssociationMap** 建立映射关系存储在 **AssociationHashMap** 中
 
 
 #### 3、扩展
 
  **扩展的作用**
 
 * 1、声明私有属性
 * 2、声明私有方法
 * 3、声明私有成员变量
 
  **扩展的特点**
 
 * 编译时决议
 * 只以声明的形式存在，多数情况下寄生于宿主类的.m中
 * 不能为系统类添加l扩展
 
  #### 4、代理
 
 * 代理是一种设计模式-代理模式
 * 以@protocol形式体现
 * 一对一的方式传递
 * 可以定义成员属性和方法，require 必须实现 option 非必须实现
 * 通过weak关键字规避循环引用
 
 ![IMG_3903](IMG_3903.PNG)
 
   #### 5、通知
 
 * 是使用**观察者模式**来实现的用于**跨层传递**消息的机制
 * 一对多的传递方式
 
  **通知机制**
 
 ![IMG_3904](IMG_3904.PNG)
 
 ![IMG_3905](IMG_3905.PNG)
 
 
  #### 6、KVO
  
  **KVO**
 
 ![IMG_3906](IMG_3906.PNG)

 ![IMG_3907](IMG_3907.PNG)
 
 在动态运行时指针混写
 
  **KVO实现原理**
 
 ![IMG_3908](IMG_3908.PNG)
 
  **手动KVO**
 * willChangeValueForKey:
 * didChangeValueForKey:  -> 触发监听回调
 
 
 #### 7、KVC
 
 ![IMG_3909](IMG_3909.PNG)
 
  **valueForKey**
 
 ![IMG_3910](IMG_3910.PNG)
 
 ![IMG_3911](IMG_3911.PNG)
 
  **setValue: ForKey**
  
 ![IMG_3912](IMG_3912.PNG)
 
 ![IMG_3913](IMG_3913.PNG)
 
 #### 8、属性关键字
 
  **读写权限**
 
 * 1、readonly
 
 * 2、readwrite（默认）
 
  **原子性**
 
 * atomic（默认）可以保证对成员属性的赋值和获取是线程安全的，但是操作和访问并不是线程安全的。eg： Array 的赋值和获取是线程安全的，但是添加、移除等操作并不是线程安全。
 
 * nonatomic
 
  **引用计数**
 
 * retain/strong：修饰对象
 
 * assign（修饰基础数据类型/对象）/unsafe_unretained （MRC）
 
 * weak
 
 * copy
 
 
  **assign特点**
 
 * 1、修饰基本数据类型
 * 2、修饰对象类型，不改变其引用计数
 * 3、会产生悬垂指针（对象被释放会，指针能然指向原对象的内存地址，继续访问会导致内存异常）
 
  **weak特点**
 
 * 1、不改变被修饰对象的引用计数
 * 2、所指向对象在被释放之后会自动置为nil
 
  **copy特点**
 
 ![IMG_3916](IMG_3916.PNG)
 
 ![IMG_3917](IMG_3917.PNG)
 
 对array进行操作（添加、删除等），会导致内存异常
 
  **浅拷贝（指针复制）**
  就是对内存地址的复制，让目标对象的指针和源对象指向同一片内存空间
 * 1、会增加被拷贝对象的引用计数
 * 2、并没发生新的内存分配
 
  **深拷贝（内容复制）**
  让目标对象指针和源对象指针指向两片内存相同的内存空间
 * 1、不会增加被拷贝对象的引用计数
 * 2、发生新的内存分配
 
  **其他**
 
 ![IMG_3918](IMG_3918.PNG)
 
 为什么要进行!=判断？
 如果传入的obj是当前obj，先进行release操作，可能导致obj被释放，在进行retain操作，就会导致内存异常，所以!=判断是来规避可能的异常情况。
 
*/
