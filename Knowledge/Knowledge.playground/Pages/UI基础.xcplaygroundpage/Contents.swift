/*:
 # UI视图

 * 重用机制、原理
 * 数据源同步
 * UIView与CALayer的区别
 * 事件传递&视图响应
 * 图像显示原理
 * 卡顿&掉帧
 * 绘制原理&异步绘制
 * 离屏渲染
 
  ----------

 #### 1、重用机制&原理
 
identifer作为Cell标记 ，从重用池取出标记为identifer的Cell展示在当前屏幕，没有就创建新的Cell。
 
当Cell移出屏幕，就回加入到重用池，reload也会把Cell放回重用池。
 
#### 2、数据源同步
 
 >（在主线程在删除操作，在子线程网络请求做刷新操作—> 多线程访问数据）

* A. 并发访问数据拷贝 （子线程拷贝数据做刷新操作，主线程记录删除操作，并发后回到主线同步数据）
 
 缺点：需要记录数据的操作，以及频繁数据源的拷贝，消耗内存。

* B. 串行访问 （主线程的删除操作，以及子线程网络请求后的刷新操作，都放在串行队列同步进行、再回到主线程刷新UI）

缺点：当有耗时操作时，会有延时。

#### 3、UIView与CALayer的区别：

* A. UIView为CALayer提供显示的内容，以及负责处理触摸等事件，参与响应链。
* B. CALayer负责显示内容contents（bitmap的位图）

设计原则：单一职责的原则

#### 4、事件传递&视图响应

**事件传递：**
* A. hitTest: withEvent -> UIView?                  // 哪个视图响应事件
 
* B. pointInside: withEvent     -> Bool            // 事件点击位置，是否在视图的响应范围内
 
 ![IMG_3886](IMG_3886.PNG)
 
 ![IMG_3885](IMG_3885.PNG)

**注意： 倒序遍历子视图**

重写hitTest: withEvent可改变响应时间的视图
 
重写pointInside: withEvent可以改变视图响应事件的范围

**视图响应：**
* A. touchsBegan: withEvent
* B. touchesMoved: withEvent
* C. touchesEnded: withEvent

 ![IMG_3887](IMG_3887.PNG)

#### 5、图像显示原理

CPU/GPU

 ![IMG_3888](IMG_3888.PNG)
 
 ![IMG_3889](IMG_3889.PNG)
 
 ![IMG_3890](IMG_3890.PNG)
 
 ![IMG_3891](IMG_3891.PNG)
 
 Layout: UI布局，文本计算等
 
 Display: 绘制（eg：drawRect:）
 
 Frame Buffer：帧缓存区
 
#### 6、卡顿&掉帧

原因： 在规定的16.7ms（1s/60FPS）之内，在下一帧Vsync信号到来之前，CPU和GPU并没有完成下一帧信号的合成，导致卡顿和掉帧。
 
 ![IMG_3897](IMG_3897.PNG)

**滑动优化：**
CPU
* 1、对象创建、调整、销毁 -> 子线程
* 2、预排版（布局计算、文本计算）-> 子线程
* 3、预渲染（文本等异步绘制，图片编解码等）-> 子线程

GPU
* 1、纹理渲染 -> 避免离屏渲染、异步绘制
* 2、视图混合 （视图的合成，合成像素值）-> 减轻层级复杂

#### 7、绘制原理&异步绘制
 
**UIView绘制原理：**
 
 ![IMG_3892](IMG_3892.PNG)

 只有当前Runloop即将结束的时候才会调用[CALayer display]
 
**异步绘制：**
 
 异步绘制只要依赖于是否遵守实现displayLayer：
 
 ![IMG_3893](IMG_3893.PNG)
 
 ![IMG_3894](IMG_3894.PNG)
 
 ![IMG_3895](IMG_3895.PNG)

#### 8、离屏渲染

**在屏渲染**：当前屏幕渲染，指的是GPU的渲染操作在当前用于显示的屏幕缓冲区中进行
 
**离屏渲染**：指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作

当我们在设置UI视图的某些属性，标记为它在未被预合成之前，不能用于当前屏幕直接显示的时候，就会触发离屏渲染，而离屏渲染起源与GPU层面，指的是在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。

**触发：**
* 1、圆角（当和maskToBounds一起使用）
* 2、图层蒙版
* 3、阴影
* 4、光栅化

**为什么要避免：**

在触发离屏渲染会增加GPU的工作量，增加了GPU的工作量，很有可能导致CPU+GPU工作耗时加起来的总耗时超过16.7ms，从而导致卡顿和掉帧。

* 1、会创建新的渲染缓冲区， 内存开销
* 2、上下文切换，GPU开销

 */
